//
// findinf.cc -- to find points up to given naive height, giving a
// Z-basis for the subgroup generated by the points found, modulo
// torsion
//
// Version 2:  apply "optimal x-shift" to curve before searching

#include "interface.h"
#include "compproc.h"

#include "matrix.h"
#include "subspace.h"

#include "points.h"
#include "polys.h"
#include "curvemod.h"
#include "pointsmod.h"
#include "ffmod.h"
#include "divpol.h"
#include "tlss.h"
#include "elog.h"
#include "saturate.h"

#include "sieve_search.h"
#include "htconst.h"

#include "mwprocs.h"

int main()
{
  set_precision("Enter number of decimal places");
  initprimes("PRIMES",0);

  bigfloat reg, ht_limit;
  bigint u,r,s,t;
  int verbose = 1, modopt=0, pp=1, change_flag; 
  long blength, rank, maxrank;
  cout<<"\nenter search limit: ";      cin>>ht_limit;
  cout<<"verbose (0/1)? ";             cin >>verbose;
  cout<<"process points found (1) or just list them (0): "; cin>>pp;
  modopt=0;
  //  cout<<"moduli option (0 (Stoll)/ 1/2/3)?";      cin >> modopt;
  Curve E;

  while (1)
    {
      cout<<"\nInput a curve: ";      cin >> E;
      if ( E.isnull() ) break;
      Curvedata C(E);
      cout << "Curve " << E << endl;
      Curvedata C_min = C.minimalize(u,r,s,t);
      change_flag = ((Curve)C_min) != E;
      if(change_flag)
	{
	  cout<<"Standard minimal curve"<<(Curve)C_min<<endl;
	  cout<<"(points found will be transferred back at end)"<<endl;
	  cout<<"Transformation: \t[u,r,s,t] = ["<<u<<","<<r<<","<<s<<","<<t<<"]\n";
	}
      bigint x_shift;
      Curvedata C_opt = opt_x_shift(C_min,x_shift);
      int shift_flag = !is_zero(x_shift);
      if(shift_flag)
	{
	  cout<<"Shifted minimal curve"<<(Curve)C_opt<<endl;
	  cout<<"(points found will be transferred back at end)"<<endl;
	  cout<<"Transformation: \t[u,r,s,t] = [0,"<<x_shift<<",0,0]\n";
	}

      double hc = height_constant(C_opt);
      cout<<"Height constant = "<<hc<<endl;
      
      Point P(C);
      Point Q(C_min);
      Point R(C_opt);
      cout<<"enter number of known points: ";      cin >>blength;
      cout<<"enter max rank to stop when this is reached (-ve for none): ";
      cin >>maxrank; if(maxrank<0) maxrank=999;
      vector<Point> known_points(blength);
      if (blength)
	{ 
	  for (long j=0; j<blength; j++)
	    { cout<<"\n  enter point "<<(j+1); 
	    if(change_flag) cout<<" on original curve";
	      cout<<": ";
	      cin >> P;
	      if ( P.isvalid() ) 
		{
		  cout<<"Height on original curve = "<<height(P)<<endl;
		  Q = shift(P,&C_min,u,r,s,t,0);
		  R = shift(Q,&C_opt,u,x_shift,BIGINT(0),BIGINT(0),0);
		  known_points[j] = R;
		  if(change_flag||shift_flag) 
		    {
		      cout<<P<<" on "<<E<<"\nmaps to "<<
			R<<" on "<<(Curve)C_opt<<", with height "<<height(R)
			  <<endl;
		    }
		}
	      else 
		{
		  cout<<"Bad point -- not on curve. Start all over again.\n";
		  break; 
		}
	    }
	}

      mw mwbasis(&C_opt, verbose, pp, maxrank);
      if(blength)
	{
	  mwbasis.process(known_points);
	  rank = mwbasis.getrank();
	  cout<<"Rank of known points is "<<rank<<endl;
	  cout<<"\nregulator is "<<mwbasis.regulator()<<endl<<endl;
	}

      mwbasis.search(ht_limit, modopt, verbose);
      
      if(pp)
	{
	  rank = mwbasis.getrank();
	  cout<<"Rank of points found is "<<rank<<endl;
	  vector<Point> b = mwbasis.getbasis();
	  for (long i=0; i<rank; i++)
	    { 
	      R = b[i];
	      bigfloat hR = height(R);
	      cout << "\tGenerator "<<(i+1)<<" is "<<R<<"; ";
	      cout << "height "<<hR<<endl;
	      if(shift_flag)
		{
		  Q = shift(R,&C_min,u,x_shift,BIGINT(0),BIGINT(0),1);
		  cout<<"\t--maps back to "<<Q<<" on curve "<<(Curve)C_min
		      <<endl;
		}
	      else Q=R;
	      if(change_flag)
		{
		  P = shift(Q,&C,u,r,s,t,1);
		  cout<<"\t--maps back to "<<P<<" on curve "<<E<<endl;
		}
	      else P=Q;
	      b[i]=P;
	    }
	  if(rank>1) cout<<"\t\tregulator is "<<mwbasis.regulator()<<endl;
	  if(ht_limit>hc)
	    {
	      cout<<"All points with canonical height less than "
		  <<(ht_limit-hc)<<" should have been found"<<endl;     
	    }
	  cout<<endl;
// Pari output:
	  cout<<"[";
	  for(long i=0; i<rank; i++)
	    {
	      if(i) cout<<",";
	      output_pari(cout,b[i]);
	    }
	  cout<<"]\n";
	}
    }
  cout<<endl;
}

//end of file findinf2.cc





